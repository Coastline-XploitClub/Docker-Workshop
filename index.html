<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Week 1 - CCDC Workshop</title>
    <link
      rel="stylesheet"
      href="https://bootswatch.com/5/darkly/bootstrap.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Montserrat", sans-serif;
      }

      pre {
        background-color: #2c3e50;
        color: #eae9e9;
        padding: 1rem;
        border-radius: 0.25rem;
        white-space: pre-wrap;
        word-wrap: break-word;
      }

      .tab-content {
        border: 1px solid #dee2e6;
        border-top: 0;
        padding: 1.5rem;
        border-radius: 0 0 0.375rem 0.375rem;
      }

      .nav-pills .nav-link {
        border-radius: 0.375rem 0.375rem 0 0;
      }
    </style>
  </head>

  <body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
      <div class="container-fluid">
        <a class="navbar-brand" href="index.html">CCDC Workshop</a>
        <button
          class="navbar-toggler"
          type="button"
          data-bs-toggle="collapse"
          data-bs-target="#navbarNav"
          aria-controls="navbarNav"
          aria-expanded="false"
          aria-label="Toggle navigation"
        >
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
          <ul class="navbar-nav">
            <li class="nav-item">
              <a class="nav-link" href="index.html">Home</a>
            </li>
            <li class="nav-item">
              <a class="nav-link active" aria-current="page" href="week1.html"
                >Week 1</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link" href="week2.html">Week 2</a>
            </li>
          </ul>
        </div>
      </div>
    </nav>

    <div class="container mt-4">
      <ul class="nav nav-pills nav-fill" id="week1Tab" role="tablist">
        <li class="nav-item" role="presentation">
          <button
            class="nav-link active"
            id="lecture-tab"
            data-bs-toggle="tab"
            data-bs-target="#lecture-content"
            type="button"
            role="tab"
            aria-controls="lecture-content"
            aria-selected="true"
          >
            <i class="bi bi-easel-fill"></i> Lecture & Demo
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="lab-tab"
            data-bs-toggle="tab"
            data-bs-target="#lab-content"
            type="button"
            role="tab"
            aria-controls="lab-content"
            aria-selected="false"
          >
            <i class="bi bi-terminal-fill"></i> Lab
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="homework-tab"
            data-bs-toggle="tab"
            data-bs-target="#homework-content"
            type="button"
            role="tab"
            aria-controls="homework-content"
            aria-selected="false"
          >
            <i class="bi bi-pencil-square"></i> Homework
          </button>
        </li>
      </ul>
      <div class="tab-content" id="week1TabContent">
        <div
          class="tab-pane fade show active"
          id="lecture-content"
          role="tabpanel"
          aria-labelledby="lecture-tab"
        >
          <h1>
            <i class="bi bi-easel-fill"></i> Week 1: Docker Basics - Lecture &
            Demo
          </h1>
          <h2>1. Core Concepts</h2>
          <p>
            Let's break down the basics of Docker. These are the building blocks
            for running and managing containers.
          </p>

          <h3>Images</h3>
          <p>
            A Docker image is like a ready-to-go package with everything your
            app needs: code, tools, and settings.
          </p>
          <ul>
            <li>
              <strong>Think of it like</strong>: A blueprint or a class in
              programming.
            </li>
            <li><strong>Key Point</strong>: Images never change once built.</li>
            <li>
              <strong>Layers</strong>: Each line in a
              <code>Dockerfile</code> adds a layer. Layers make builds fast and
              let Docker reuse stuff. Pulling an image means pulling all its
              layers.
            </li>
          </ul>
          <h3>Explaining the Layered Filesystem</h3>
          <p>
            When you pull an image, you'll see lots of "Pull complete" messages.
            These are the layers.
          </p>
          <ul>
            <li>
              <strong>How it works</strong>:
              <ul>
                <li>
                  Each line in a <code>Dockerfile</code> (like
                  <code>FROM</code>, <code>RUN</code>, <code>COPY</code>) adds a
                  layer.
                </li>
                <li>Layers can't be changed.</li>
                <li>
                  When you start a container, Docker adds a small writable layer
                  on top.
                </li>
                <li>
                  Any changes you make in the running container go in this top
                  layer.
                </li>
                <li>
                  Delete the container, and this layer is gone. The image layers
                  stay the same.
                </li>
              </ul>
            </li>
            <li>
              <strong>Why it's cool</strong>:
              <ul>
                <li>
                  <strong>Efficient</strong>: Layers are shared. If two images
                  use the same base, Docker only stores it once.
                </li>
                <li>
                  <strong>Fast</strong>: Spinning up a container is quick
                  because you're just adding a tiny layer.
                </li>
                <li>
                  <strong>Versioning</strong>: Each layer has a unique hash, so
                  you can track changes.
                </li>
              </ul>
            </li>
          </ul>

          <h3>Containers</h3>
          <p>
            A container is just a running copy of an image. You can start, stop,
            move, or delete it with Docker.
          </p>
          <ul>
            <li>
              <strong>Think of it like</strong>: An instance of a class, or a
              house built from a blueprint.
            </li>
            <li>
              <strong>Key Point</strong>: Containers are separated from each
              other and the host, but you can let them talk if you want. Each
              one gets its own space for files, CPU, and memory.
            </li>
            <li>
              <strong>State</strong>: Containers don't keep data by default. If
              you delete a container, its files are gone unless you use a
              volume. This is by design to keep containers lightweight and
              portable, and to make them easy to recreate.
            </li>
          </ul>

          <h3>Volumes</h3>
          <p>
            Volumes are how you save data from containers. Docker manages them,
            and they're the best way to keep stuff safe if your application is
            stateful.
          </p>
          <ul>
            <li>
              <strong>Why use them?</strong> To keep data even after a container
              is gone.
            </li>
            <li>
              <strong>Types</strong>:
              <ul>
                <li>
                  <strong>Named Volumes</strong>: Docker handles these. You just
                  give them a name. Data lives in Docker's storage on the host.
                  <br />
                  (<i>Best choice for most cases.</i>)
                </li>
                <li>
                  <strong>Bind Mounts</strong>: You link a folder from your
                  computer to the container.<br />
                  (<i>Not as portable and can be slower.</i>)
                </li>
              </ul>
            </li>
          </ul>

          <h3>Networks</h3>
          <p>
            Containers can talk to each other and the outside world using Docker
            networks.
          </p>
          <ul>
            <li>
              <strong>Bridge Network (Default)</strong>: Docker makes a default
              <code>bridge</code> network. Containers on it can talk to each
              other with their own IPs.
            </li>
            <li>
              <strong>User-Defined Bridge Networks</strong>: Great for apps with
              multiple containers. They get their own space and can find each
              other by name.
            </li>
            <li>
              <strong>Host Network</strong>: The container uses the host's
              network. Its hostname matches the host. This is not recommended
              for production environments and comes with security risks.
            </li>
            <li>
              <strong>Overlay Network</strong>: For connecting containers across
              different machines in a Swarm. This is used in Docker Swarm mode.
            </li>
            <li>
              <strong>IPvlan Network</strong>: Gives containers direct access to
              the physical network by assigning them IPs from the same subnet as
              the host. Containers appear as separate devices on the network.
              Useful when you need containers to be directly addressable on your
              LAN without NAT.
            </li>
            <li>
              <strong>Macvlan Network</strong>: Assigns a unique MAC address to
              each container, making them appear as physical devices on the
              network. Each container gets its own IP and MAC address. Perfect
              for legacy applications that expect to be directly on the network
              or when you need to avoid port mapping.
            </li>
          </ul>

          <hr />

          <h2>2. Docker CLI Essentials</h2>
          <p>
            Before diving into practical demonstrations, let's cover the
            essential Docker CLI commands you'll use daily in CCDC competitions
            and real-world scenarios. These commands form the foundation of
            Docker operations and will help you troubleshoot, deploy, and manage
            containerized services effectively.
          </p>

          <h3>System Information & Setup</h3>
          <p>
            Understanding your Docker environment is crucial for effective
            troubleshooting and system management.
          </p>

          <h4>Check Docker Installation & Version</h4>
          <pre><code># Check Docker version
docker --version

# Get detailed version information
docker version

# Display system-wide Docker information
docker info</code></pre>

          <p><strong>Use Cases:</strong></p>
          <ul>
            <li>Verify Docker is properly installed on competition systems</li>
            <li>Check available resources (CPU, memory, storage)</li>
            <li>Identify Docker daemon configuration issues</li>
          </ul>

          <h4>System Resource Management</h4>
          <pre><code># Show Docker disk usage
docker system df

# Get detailed breakdown of space usage
docker system df -v

# Clean up unused containers, networks, images, and build cache
docker system prune

# Aggressive cleanup (includes unused images)
docker system prune -a</code></pre>

          <p>
            <strong>CCDC Tip:</strong> Use
            <code>docker system prune</code> sparingly and only when necessary
            during competitions to free up disk space. It's easy to accidentally
            delete important images or containers.
          </p>

          <h3>Image Management</h3>
          <p>
            Images are the building blocks of containers. Efficient image
            management is essential for quick deployments and troubleshooting.
          </p>

          <h4>Finding and Downloading Images</h4>
          <pre><code># Search for images on Docker Hub
docker search nginx

# Pull an image from Docker Hub
docker pull nginx:latest

# Pull a specific version
docker pull nginx:1.24-alpine

# Pull from a private registry
docker pull myregistry.com/myapp:v1.0</code></pre>

          <h4>Examining Local Images</h4>
          <pre><code># List all local images
docker images

# List images with full information
docker images --no-trunc

# Filter images
docker images nginx
docker images --filter "dangling=true"

# Create a dangling image (no name/tag)
echo "FROM alpine" | docker build -
docker images --filter "dangling=true"

# Remove a dangling image
docker rmi $(docker images -q -f dangling=true)

# Show image sizes
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"</code></pre>

          <h4>Image Inspection & History</h4>
          <pre><code># Get detailed information about an image
docker inspect nginx:latest

# Show image build history and layers
docker history nginx:latest

# Show image creation commands
docker history --no-trunc nginx:latest

# Show image creation commands formatted in json
docker history --format "{{json .}}" --no-trunc nginx:latest | jq .</code></pre>

          <p>
            <strong>CCDC Scenario:</strong> When an inject asks "What version of
            Nginx are you running?", use <code>docker inspect</code> to quickly
            find version information and build details. This is also useful for
            identifying vulnerabilities in the image based on software versions
            or build details.
          </p>

          <h4>Image Cleanup</h4>
          <pre><code># Pull several versions and tags of Nginx
docker pull nginx:1.20
docker pull nginx:1.21-alpine
docker pull nginx:1.22-perl

# Remove a specific image
docker rmi nginx:1.20

# Remove multiple images
docker rmi nginx:1.21-alpine nginx:1.22-perl

# Create a dangling/unused image
echo "FROM alpine" | docker build -
docker images --filter "dangling=true"

# Remove all unused images
docker image prune

# Remove all images (dangerous!)
docker rmi $(docker images -q)</code></pre>

          <h3>Container Lifecycle Management</h3>
          <p>
            Managing container lifecycles efficiently is critical during CCDC
            competitions when services need to be deployed, updated, or
            recovered quickly.
          </p>

          <h4>Creating and Running Containers</h4>
          <pre><code># Basic container run
docker run hello-world

# Run with common options
docker run -d --name web-server -p 8080:80 nginx

# Run interactively
docker run -it ubuntu bash

# Run with environment variables
docker run -e MYSQL_ROOT_PASSWORD=secret mysql:8.0

# Run interactive container and remove it after exit
docker run -it --rm ubuntu bash

# Run with volume mounts in background
docker run -d -v data-vol:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=secret mysql:8.0

</code></pre>

          <p><strong>Key Flags Explained:</strong></p>
          <ul>
            <li><code>-d</code>: Detached mode (runs in background)</li>
            <li><code>-it</code>: Interactive terminal</li>
            <li><code>-p</code>: Port mapping (host:container)</li>
            <li><code>-v</code>: Volume mounting</li>
            <li><code>-e</code>: Environment variables</li>
            <li><code>--name</code>: Container name</li>
            <li><code>--network</code>: Network assignment</li>
            <li><code>--restart</code>: Restart policy</li>
          </ul>

          <h4>Monitoring Running Containers</h4>
          <pre><code># List running containers
docker ps

# List all containers (running and stopped)
docker ps -a

# Show only container IDs
docker ps -q

# Custom format output
docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

# Filter containers
docker ps --filter "status=running"
docker ps --filter "name=web"</code></pre>

          <h4>Container Control</h4>
          <pre><code># Stop a running container
docker stop web-server
docker start web-server

# Stop with timeout
docker stop -t 30 web-server
docker start web-server

# Force stop (kill)
docker kill web-server

# Start a stopped container
docker start web-server

# Restart a container
docker restart web-server

# Pause/unpause a container
docker pause web-server
docker ps
docker unpause web-server</code></pre>

          <p>
            <strong>CCDC Tip:</strong> Use <code>docker restart</code> instead
            of <code>stop</code> + <code>start</code>
            for faster service recovery during incidents.
          </p>

          <h3>Container Interaction & Debugging</h3>
          <p>
            When services break during CCDC competitions, these commands help
            you quickly diagnose and fix issues.
          </p>

          <h4>Executing Commands in Containers</h4>
          <pre><code># Execute a command in a running container
docker exec web-server ls /var/log

# Get an interactive shell
docker exec -it web-server bash

# Execute as a specific user
docker exec -it --user root web-server bash

# Execute with environment variables
docker exec -it -e DEBUG=1 web-server bash</code></pre>

          <h4>Viewing Logs</h4>
          <pre><code># View container logs
docker logs web-server

# Follow logs in real-time
docker logs -f web-server

# Curl the webserver at localhost:8080
curl http://localhost:8080

# Show only recent logs
docker logs --tail 50 web-server

# Show logs with timestamps
docker logs -t web-server

# Show logs from specific time
docker logs --since "2024-01-01T00:00:00Z" web-server</code></pre>

          <p>
            <strong>CCDC Scenario:</strong> When a web service goes down,
            quickly check logs with <code>docker logs -f web-server</code> to
            identify the root cause.
          </p>

          <h4>Copying Files</h4>
          <pre><code># Copy file from container to host
docker cp web-server:/etc/nginx/nginx.conf ./nginx.conf

# Copy file from host to container
echo "Hello, world!" > hello.txt
docker cp ./hello.txt web-server:/hello.txt
docker exec -it web-server cat /hello.txt

# Copy entire directory
docker cp web-server:/etc/nginx ./backup/</code></pre>

          <h4>Container Statistics</h4>
          <pre><code># Show live resource usage
docker stats

# Show stats for specific containers
docker stats web-server

# Show stats once (no live update)
docker stats --no-stream

# Stop all containers and remove them
docker stop $(docker ps -q)
docker rm $(docker ps -a -q)


</code></pre>

          <h3>Volume Management</h3>
          <p>
            Persistent storage is critical for databases and application data in
            CCDC environments.
          </p>

          <h4>Volume Operations</h4>
          <pre><code># Create a named volume
docker volume create app-data

# List all volumes
docker volume ls

# Inspect a volume
docker volume inspect app-data

# Remove a volume
docker volume rm app-data

# Remove unused volumes
docker volume prune</code></pre>

          <h4>Volume Usage Examples</h4>
          <pre><code># Run container with named volume
docker run -d -v app-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=secret mysql:8.0

# Run with bind mount (not recommended for production)
docker run -d -v ~:/container/data nginx
</code></pre>

          <p>
            <strong>CCDC Best Practice:</strong> Always use named volumes
            instead of bind mounts for database storage to ensure portability
            and proper backup procedures.
          </p>

          <h3>Network Management</h3>
          <p>
            Container networking is essential for multi-service applications
            common in CCDC scenarios.
          </p>

          <h4>Network Operations</h4>
          <pre><code># List networks
docker network ls

# Inspect a network
docker network inspect bridge

# Create a custom network
docker network create app-network
docker network inspect app-network
docker network rm app-network

# Create network with specific subnet
docker network create --subnet=172.20.0.0/16 app-network
docker network inspect app-network</code></pre>

          <h4>Network Usage</h4>
          <pre><code># Run container on specific network
docker run -d --network app-network --name web nginx

# Connect running container to network
docker run -d -p 8080:80 -v nginx-webroot:/usr/share/nginx/html --name web-server nginx:1.24-alpine
docker exec -it web-server ip addr show 
docker exec -it web-server ping -c 3 web
docker network connect app-network web-server
docker exec -it web-server ip addr show 
docker exec -it web-server ping -c 3 web

# Disconnect container from network
docker network disconnect app-network web-server
docker exec -it web-server ip addr show</code></pre>

          <p>
            <strong>CCDC Scenario:</strong> Create isolated networks for
            different services (web-tier, db-tier) to implement network
            segmentation and improve security.
          </p>

          <h3>Troubleshooting Commands</h3>
          <p>
            These commands are invaluable during CCDC competitions when time is
            critical.
          </p>

          <h4>Quick Diagnostics</h4>
          <pre><code># Check if container is running
docker ps | grep web-server

# Get container's IP address
docker inspect web-server | grep IPAddress

# Check container's mounted volumes
docker inspect web-server | grep -A 10 Mounts

# Verify port mappings
docker port web-server

# Check container resource usage
docker stats web-server --no-stream</code></pre>

          <h4>Container Health Checks</h4>
          <pre><code># Check container processes
docker exec web-server ps aux

# Check disk space
docker exec web-server df -h

# Check service status for alpine
docker exec web service --status-all

# Delete everything
docker kill $(docker ps -q)
docker system prune -af
docker volume prune -a
</code></pre>

          <p>
            <strong>CCDC Tip:</strong> Create a quick diagnostic script that
            runs these commands in sequence to rapidly assess container health
            during incidents.
          </p>

          <h3>Practical Exercise: CLI Command Chain</h3>
          <p>
            Let's practice a common CCDC scenario: deploying a web service and
            troubleshooting it.
          </p>

          <pre><code># 1. Check system status
docker info

# 2. Pull required image
docker pull nginx:alpine

# 3. Create dedicated network
docker network create web-net

# 4. Create volume for logs
docker volume create nginx-logs

# 5. Run container with proper configuration
docker run -d \
  --name production-web \
  --network web-net \
  -p 8080:80 \
  -v nginx-logs:/var/log/nginx \
  nginx:alpine

# 6. Verify deployment
docker ps | grep production-web
docker logs production-web

# 7. Test connectivity
curl http://localhost:8080

# 8. Monitor resources
docker stats production-web --no-stream

# 9. Backup configuration
docker cp production-web:/etc/nginx/nginx.conf ./nginx-backup.conf

# 10. Delete everything
docker kill $(docker ps -q)
docker system prune -af
docker volume prune -a
</code></pre>

          <p>
            This command sequence demonstrates the typical workflow for
            deploying and verifying a containerized service in a CCDC
            environment.
          </p>

          <hr />

          <h2>2. Lecture & Demo: Nginx and MySQL</h2>
          <p>
            Let's run a web server (<code>nginx</code>) and a database
            (<code>MySQL</code>) in Docker. We'll use named volumes to save
            their data.
          </p>

          <h3>Running Nginx & Showing Persistence</h3>
          <p>
            Here's how to serve a default page, swap it for your own, and prove
            it sticks around even if you restart the container.
          </p>

          <ol>
            <li>
              <strong>Pull the Nginx Image:</strong>
              <pre><code>docker pull nginx:latest</code></pre>
            </li>
            <li>
              <strong>Run the Container and Show the Default Page:</strong>
              <p>
                We will create a named volume called
                <code>nginx-webroot</code> and mount it to
                <code>/usr/share/nginx/html</code>. Initially, Docker will
                populate this volume with the default content from the Nginx
                image.
              </p>
              <pre><code>docker run --name my-nginx -d -p 8080:80 -v nginx-webroot:/usr/share/nginx/html nginx</code></pre>
              <ul>
                <li>
                  <code>--name my-nginx</code>: Assigns a name to the container
                  for easy reference.
                </li>
                <li>
                  <code>-d</code>: Runs the container in detached mode (in the
                  background).
                </li>
                <li>
                  <code>-p 8080:80</code>: Maps port 8080 on the host to port 80
                  in the container.
                </li>
                <li>
                  <code>-v nginx-webroot:/usr/share/nginx/html</code>: Creates a
                  named volume <code>nginx-webroot</code> and mounts it.
                </li>
              </ul>
              <p>
                <strong>Verification:</strong> Open a web browser to
                <code>http://localhost:8080</code>. You should see the default
                "Welcome to nginx!" page.
              </p>
            </li>
            <li>
              <strong>Create and Deploy Custom Web Content:</strong>
              <p>
                Instead of using inline echo commands, let's create a proper
                HTML file and deploy it using best practices. This approach is
                more maintainable and secure.
              </p>

              <p>
                <strong>Step 3a: Create a custom HTML file on the host</strong>
              </p>
              <pre><code># Create a project directory
mkdir -p ~/ccdc-web-content
cd ~/ccdc-web-content

# Create a professional HTML file
cat > index.html << 'EOF'
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;CCDC Training Environment&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; margin: 40px; background: #f4f4f4; }
        .container { background: white; padding: 20px; border-radius: 8px; }
        .header { color: #2c3e50; border-bottom: 2px solid #3498db; }
        .status { color: #27ae60; font-weight: bold; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;h1 class="header"&gt;CCDC Training Web Server&lt;/h1&gt;
        &lt;p class="status"&gt;✓ Container successfully deployed&lt;/p&gt;
        &lt;p&gt;This page is served from a persistent Docker volume.&lt;/p&gt;
        &lt;p&gt;Server: Nginx running in Docker container&lt;/p&gt;
        &lt;p&gt;Deployment time: $(date)&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
EOF

# Verify the file was created
ls -la index.html
cat index.html</code></pre>

              <p>
                <strong>Step 3b: Deploy the content using docker cp</strong>
              </p>
              <pre><code># Copy the file directly into the running container
docker cp index.html my-nginx:/usr/share/nginx/html/index.html</code></pre>

              <p><strong>Why this approach is better:</strong></p>
              <ul>
                <li>
                  <strong>Version Control</strong>: HTML files can be tracked in
                  git
                </li>
                <li>
                  <strong>Security</strong>: No shell injection risks from echo
                  commands
                </li>
                <li>
                  <strong>Maintainability</strong>: Easy to edit and update
                  content
                </li>
                <li>
                  <strong>CCDC Best Practice</strong>: Separates code from
                  deployment, making it easier to manage during competitions
                </li>
              </ul>

              <p>
                <strong>Verification:</strong> Refresh your browser at
                <code>http://localhost:8080</code>. The page should update
                instantly to show your professional website. This demonstrates
                both persistent storage and proper content deployment practices.
              </p>
            </li>
            <li>
              <strong
                >Alternative Method: Direct Host Editing (Not
                Recommended)</strong
              >
              <p>
                It is also possible to find the volume's location on the host
                and edit the files directly. While this can be useful for quick
                debugging, it is <strong>not a recommended practice</strong>.
              </p>
              <p>
                <strong>a. Find the volume path:</strong><br />First, use
                <code>docker volume inspect</code> to find the
                <code>Mountpoint</code> on the host filesystem.
              </p>
              <pre><code>docker volume inspect nginx-webroot</code></pre>
              <p>
                The output will show you the full path, which usually looks like
                <code>/var/lib/docker/volumes/nginx-webroot/_data</code>.
              </p>
              <p>
                <strong>b. Edit the file as root:</strong><br />Because Docker
                manages this directory, you will need
                <code>sudo</code> permissions to modify its contents.
              </p>
              <pre><code># Note the need for sudo and the full path from the inspect command
sudo sh -c "echo '&lt;h1&gt;Updated Directly on the Host\!&lt;/h1&gt;' > path/to/volumes/nginx-webroot/_data/index.html"</code></pre>
              <p>Refresh your browser, and you will see the new content.</p>
              <p><strong>c. Why is this discouraged?</strong></p>
              <ul>
                <li>
                  <strong>Portability:</strong> This method only works on Linux.
                  Docker on Windows and Mac uses a virtual machine, so this path
                  is not directly accessible. The
                  <code>docker run</code> command works on all platforms.
                </li>
                <li>
                  <strong>Permissions:</strong> It requires root access on the
                  host, which is a security risk and can lead to permission
                  errors if not handled carefully.
                </li>
                <li>
                  <strong>Breaks Encapsulation:</strong> It bypasses the Docker
                  API. The whole point of containers is to create a
                  self-contained environment. Relying on the host's filesystem
                  structure makes your setup fragile and dependent on the host's
                  configuration.
                </li>
              </ul>
            </li>
            <li>
              <strong>Simulate a Container Failure and Relaunch:</strong>
              <p>
                To prove the data is truly persistent, let's remove the
                container and launch a new one, re-attaching the same volume.
              </p>
              <pre><code># Stop and remove the old container
docker stop my-nginx
docker rm my-nginx

# Launch a new container, connecting to the existing volume
docker run --name my-nginx-reborn -d -p 8080:80 -v nginx-webroot:/usr/share/nginx/html nginx</code></pre>
            </li>
            <li>
              <strong>Final Verification:</strong>
              <p>
                Navigate to <code>http://localhost:8080</code> one last time.
                The custom page is still there, proving that the named volume
                <code>nginx-webroot</code> preserved our data independently of
                the container's lifecycle.<br />- You can inspect the volume to
                see where Docker stores it on your host:
                <code>docker volume inspect nginx-webroot</code>.
              </p>
            </li>
          </ol>

          <h3>Running MySQL</h3>
          <ol>
            <li>
              <strong>Pull the image:</strong>
              <pre><code>docker pull mysql:8.0</code></pre>
            </li>
            <li>
              <strong>Create a network:</strong>
              <p>
                For services that need to communicate, it's best to create a
                dedicated network.
              </p>
              <pre><code>docker network create my-app-net</code></pre>
            </li>
            <li>
              <strong
                >Run the container with a named volume and on the new
                network:</strong
              >
              <p>
                MySQL requires a root password to be set. We'll pass this as an
                environment variable. The database files will be stored in a
                named volume called <code>mysql-data</code>.
              </p>
              <pre><code>docker run --name my-mysql -d \
  --network my-app-net \
  -v mysql-data:/var/lib/mysql \
  -e MYSQL_ROOT_PASSWORD=my-secret-pw \
  mysql:8.0</code></pre>
              <ul>
                <li>
                  <code>--network my-app-net</code>: Attaches the container to
                  our user-defined bridge network.
                </li>
                <li>
                  <code>-v mysql-data:/var/lib/mysql</code>: Creates a named
                  volume <code>mysql-data</code> for the database files.
                </li>
                <li>
                  <code>-e MYSQL_ROOT_PASSWORD=...</code>: Sets the required
                  environment variable.
                </li>
              </ul>
            </li>
            <li>
              <strong>Verify:</strong>
              <ul>
                <li>
                  Check the logs to ensure the database started correctly:
                  <code>docker logs my-mysql</code>.
                </li>
                <li>
                  Inspect the volume:
                  <code>docker volume inspect mysql-data</code>.
                </li>
              </ul>
            </li>
          </ol>

          <h3>Network Segmentation and Security</h3>
          <p>
            This demonstration shows how to implement network segmentation for
            security in CCDC environments. We'll start with isolated networks
            (blocked communication), then show proper connectivity, and finally
            implement secure network policies.
          </p>

          <h4>
            Step 1: Deploy Services on Separate Networks (No Communication)
          </h4>
          <p>
            First, let's deploy our web server and database on completely
            separate networks to simulate poor network design.
          </p>
          <pre><code># Clean up previous containers if they exist
docker rm -f my-nginx my-mysql my-nginx-reborn 2>/dev/null || true

# Create separate networks
docker network create web-tier
docker network create db-tier

# Deploy nginx on web-tier only
docker run -d --name secure-web \
  --network web-tier \
  -p 8080:80 \
  -v nginx-webroot:/usr/share/nginx/html \
  nginx:bookworm

# Deploy MySQL on db-tier only
docker run -d --name secure-db \
  --network db-tier \
  -v mysql-data:/var/lib/mysql \
  -e MYSQL_ROOT_PASSWORD=ccdc-secret-2024 \
  -e MYSQL_DATABASE=webapp \
  -e MYSQL_USER=webuser \
  -e MYSQL_PASSWORD=web-secret \
  mysql:latest</code></pre>

          <h4>Step 2: Demonstrate Network Isolation (Communication Fails)</h4>
          <p>
            Now let's try to connect from the web server to the database - this
            should fail because they're on different networks.
          </p>
          <pre><code># Try to ping database from web container (will fail)
docker exec -it secure-web bash -c "apt update && apt install iputils-ping dnsutils iproute2 -y"
docker exec secure-web ping -c 3 secure-db

# Try to connect with MySQL client (will fail)
docker exec secure-web nslookup secure-db</code></pre>
          <p>
            <strong>Expected Result:</strong>
            <code>ping: bad address 'secure-db'</code> - the containers cannot
            see each other.
          </p>
          <p>
            <strong>CCDC Security Lesson:</strong> This demonstrates network
            isolation. If a web server is compromised, attackers cannot directly
            access the database network.
          </p>

          <h4>Step 3: Enable Secure Communication</h4>
          <p>
            Now let's properly connect these services by adding the web
            container to the database network.
          </p>
          <pre><code># Connect web container to database network
docker network connect db-tier secure-web

# Verify connectivity now works
docker exec secure-web ping -c 3 secure-db

# Test MySQL connection
docker exec secure-web nslookup secure-db</code></pre>
          <p>
            <strong>Expected Result:</strong> Ping succeeds, DNS resolution
            works.
          </p>

          <h4>Step 4: Test Database Connectivity with Real Application</h4>
          <p>
            Let's install a MySQL client in our web container and test the
            database connection.
          </p>
          <pre><code># Install MySQL client in the web container
docker exec secure-web sh -c "apt update && apt install default-mysql-client -y"

# Test database connection
docker exec secure-web mysql -h secure-db -u webuser -pweb-secret webapp -e "SELECT 'Database connection successful\!' as status;"</code></pre>

          <h4>Step 5: Network Security Best Practices</h4>
          <p>Let's demonstrate additional security measures:</p>
          <pre><code># Check which networks each container is connected to
echo "=== Web Container Networks ==="
docker inspect secure-web | grep -A 20 "Networks"

echo "=== Database Container Networks ==="
docker inspect secure-db | grep -A 20 "Networks"

# List all containers on each network
echo "=== Web-tier network members ==="
docker network inspect web-tier | grep -A 20 "Containers"

echo "=== DB-tier network members ==="
docker network inspect db-tier | grep -A 20 "Containers"</code></pre>

          <h4>Step 6: Implement Additional Security Isolation</h4>
          <p>
            For maximum security, we can remove the web container from
            unnecessary networks:
          </p>
          <pre><code># Remove web container from default bridge network (if connected)
docker network disconnect bridge secure-web 2>/dev/null || echo "Not connected to bridge"

# Verify the web container only has necessary network connections
docker exec secure-web ip route show
docker exec secure-web cat /etc/hosts</code></pre>

          <p><strong>CCDC Key Takeaways:</strong></p>
          <ul>
            <li>
              <strong>Principle of Least Privilege</strong>: Only connect
              containers to networks they actually need
            </li>
            <li>
              <strong>Network Segmentation</strong>: Separate web, application,
              and database tiers
            </li>
            <li>
              <strong>Defense in Depth</strong>: Even if one container is
              compromised, network isolation limits lateral movement
            </li>
            <li>
              <strong>Monitoring</strong>: Always verify network connectivity is
              working as expected
            </li>
          </ul>

          <h2>3. Backup and Recovery Strategy</h2>
          <p>
            In CCDC competitions, Red Team attacks often target data
            destruction. Having a comprehensive backup strategy is critical for
            service continuity. This section demonstrates how to backup all
            critical components of our containerized services.
          </p>

          <h3>Creating a Backup Directory Structure</h3>
          <p>First, let's establish a organized backup structure:</p>
          <pre><code># Create a centralized backup directory
mkdir -p ~/ccdc-backups/
cd ~/ccdc-backups

# Create timestamp for this backup session
BACKUP_DATE=$(date +%Y%m%d_%H%M%S)
mkdir -p "backup_${BACKUP_DATE}"
cd "backup_${BACKUP_DATE}"

echo "Backup session started: $(date)" > backup.log</code></pre>

          <h3>Nginx Configuration and Content Backup</h3>
          <pre><code># Backup Nginx configuration files
echo "Backing up Nginx configurations..." | tee -a backup.log
mkdir -p nginx/{config,content,logs}

# Extract Nginx main configuration
docker cp secure-web:/etc/nginx/nginx.conf nginx/config/
docker cp secure-web:/etc/nginx/conf.d/ nginx/config/

# Backup custom web content
docker cp secure-web:/usr/share/nginx/html/ nginx/content/

# Backup Nginx logs
docker cp secure-web:/var/log/nginx/ nginx/logs/

# Create nginx service info file
docker inspect secure-web > nginx/nginx-container-info.json
echo "Nginx backup completed: $(date)" | tee -a backup.log</code></pre>

          <h3>c. MySQL Database Backup</h3>
          <pre><code># Backup MySQL database and configuration
echo "Backing up MySQL database..." | tee -a backup.log
mkdir -p mysql/{dumps,config,logs}

# Create database dump (most important!)
docker exec secure-db mysqldump -u root -pccdc-secret-2024 --all-databases > mysql/dumps/all-databases.sql

# Backup specific application database
docker exec secure-db mysqldump -u root -pccdc-secret-2024 webapp > mysql/dumps/webapp-database.sql

# Backup MySQL configuration
docker cp secure-db:/etc/mysql/ mysql/config/

# Backup MySQL logs
docker cp secure-db:/var/log/ mysql/logs/

# Create mysql service info file
docker inspect secure-db > mysql/mysql-container-info.json
echo "MySQL backup completed: $(date)" | tee -a backup.log</code></pre>

          <h3>d. Docker Volume Backup</h3>
          <pre><code># Backup Docker volumes (critical for data persistence)
echo "Backing up Docker volumes..." | tee -a backup.log
mkdir -p volumes

# Backup nginx-webroot volume
docker run --rm -v nginx-webroot:/source -v $(pwd)/volumes:/backup alpine tar czf /backup/nginx-webroot.tar.gz -C /source .

# Backup mysql-data volume
docker run --rm -v mysql-data:/source -v $(pwd)/volumes:/backup alpine tar czf /backup/mysql-data.tar.gz -C /source .

# Create volume information files
docker volume inspect nginx-webroot > volumes/nginx-webroot-info.json
docker volume inspect mysql-data > volumes/mysql-data-info.json

echo "Volume backup completed: $(date)" | tee -a backup.log</code></pre>

          <h3>e. CCDC Backup Best Practices</h3>
          <p><strong>Critical Backup Components:</strong></p>
          <ol>
            <li>
              <strong>Database Dumps</strong>: Most important - always verify
              these work
            </li>
            <li>
              <strong>Configuration Files</strong>: nginx.conf, mysql configs,
              custom settings
            </li>
            <li>
              <strong>Application Data</strong>: Web content, uploaded files,
              logs
            </li>
            <li>
              <strong>Volume Data</strong>: Complete volume backups for disaster
              recovery
            </li>
            <li>
              <strong>Network Configs</strong>: For rapid service reconstruction
            </li>
          </ol>

          <p><strong>Backup Schedule for CCDC:</strong></p>
          <ul>
            <li><strong>Every 15 minutes</strong> during active competition</li>
            <li>
              <strong>Before any major changes</strong> (deployments, updates)
            </li>
            <li>
              <strong>After successful incident response</strong> (preserve
              evidence)
            </li>
            <li>
              <strong>Multiple retention points</strong> (last 4 backups
              minimum)
            </li>
          </ul>

          <p><strong>Security Considerations:</strong></p>
          <ul>
            <li>Store backups outside the compromised system</li>
            <li>Use separate authentication for backup systems</li>
            <li>Encrypt sensitive backup data</li>
            <li>Monitor backup locations for tampering</li>
          </ul>
        </div>
        <div
          class="tab-pane fade"
          id="lab-content"
          role="tabpanel"
          aria-labelledby="lab-tab"
        >
          <h1>
            <i class="bi bi-terminal-fill"></i> Week 1: Docker Fundamentals -
            Guided Lab
          </h1>
          <p>
            <strong>Objective:</strong> This lab will guide you through the
            practical steps of running containers, connecting them over a
            network, and ensuring data persistence with volumes. You will launch
            two separate containers, make them communicate, and verify that data
            saved in a volume survives container recreation.
          </p>
          <hr />
          <h2>Part 1: Container Networking</h2>
          <p>
            In this part, we will create two <code>alpine</code> containers and
            demonstrate that they can communicate with each other when attached
            to the same user-defined bridge network.
          </p>

          <h3>Step 1: Create a Docker Network</h3>
          <p>
            First, create a user-defined bridge network. This allows containers
            to resolve each other by name.
          </p>
          <pre><code>docker network create my-lab-net</code></pre>

          <h3>Step 2: Launch the First Container (<code>container-a</code>)</h3>
          <p>
            Launch an <code>alpine</code> container named
            <code>container-a</code>. The <code>-itd</code> flags start the
            container in interactive, TTY, and detached mode. The
            <code>ash</code> command keeps the container running.
          </p>
          <pre><code>docker run -itd --name container-a --network my-lab-net alpine ash</code></pre>

          <h3>
            Step 3: Launch the Second Container (<code>container-b</code>)
          </h3>
          <p>
            Launch a second <code>alpine</code> container named
            <code>container-b</code> on the same network.
          </p>
          <pre><code>docker run -itd --name container-b --network my-lab-net alpine ash</code></pre>

          <h3>Step 4: Verify Network Connectivity</h3>
          <p>
            Now, we'll confirm that <code>container-a</code> can reach
            <code>container-b</code> by its name. We'll use
            <code>docker exec</code> to run the <code>ping</code> command inside
            <code>container-a</code>.
          </p>
          <pre><code>docker exec container-a ping -c 3 container-b</code></pre>
          <p>
            You should see output similar to this, confirming that the network
            connection is working:
          </p>
          <pre><code class="language-console">PING container-b (172.19.0.3): 56 data bytes
64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.103 ms
64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.110 ms
64 bytes from 172.19.0.3: seq=2 ttl=64 time=0.115 ms</code></pre>
          <p>
            <strong>Success!</strong> You have successfully launched two
            isolated containers that can communicate over a dedicated network.
          </p>
          <hr />
          <h2>Part 2: Verifying Data Persistence</h2>
          <p>
            In this part, we will create a container with a named volume, write
            some data to that volume, then remove the container and launch a new
            one to prove the data is still there.
          </p>

          <h3>Step 1: Create a Container with a Named Volume</h3>
          <p>
            Let's create a new <code>ubuntu</code> container. We'll create a
            named volume called <code>lab-data</code> and mount it to the
            <code>/shared-data</code> directory inside the container.
          </p>
          <pre><code>docker run -itd --name data-container \
  -v lab-data:/shared-data \
  ubuntu</code></pre>

          <h3>Step 2: Write Data to the Volume</h3>
          <p>
            Now, execute a command inside <code>data-container</code> to write a
            simple text file to the mounted volume.
          </p>
          <pre><code>docker exec data-container bash -c "echo 'This data is persisted!' > /shared-data/my_file.txt"</code></pre>

          <h3>Step 3: Verify the File Exists</h3>
          <p>Check that the file was created successfully.</p>
          <pre><code>docker exec data-container cat /shared-data/my_file.txt</code></pre>
          <p>The output should be <code>This data is persisted!</code>.</p>

          <h3>Step 4: Remove the Container</h3>
          <p>
            Now, let's simulate a failure or an update by stopping and removing
            the container.
          </p>
          <pre><code>docker stop data-container
docker rm data-container</code></pre>
          <p>
            The container is gone, but the named volume
            <code>lab-data</code> remains. You can verify this by running
            <code>docker volume ls</code>.
          </p>

          <h3>Step 5: Create a New Container and Re-mount the Volume</h3>
          <p>
            Launch a new container (it can even be based on a different image,
            like <code>alpine</code>) and attach the <em>same</em> named volume
            to it.
          </p>
          <pre><code>docker run --name new-container -v lab-data:/data alpine ls /data</code></pre>
          <p>
            This command starts a new <code>alpine</code> container, mounts the
            <code>lab-data</code> volume to <code>/data</code>, and lists the
            contents of that directory. You should see
            <code>my_file.txt</code> in the output.
          </p>
          <p>To read the content, run:</p>
          <pre><code>docker run --name another-container -v lab-data:/data alpine cat /data/my_file.txt</code></pre>
          <p>The output will be <code>This data is persisted!</code>.</p>
          <p>
            <strong>Success!</strong> You have demonstrated that data stored in
            a named volume persists even after the container that created it is
            deleted.
          </p>
          <hr />

          <h2>Part 3: Multi-Service Communication</h2>
          <p>
            In this section, you will set up a realistic web application
            environment with nginx and MySQL communicating over a dedicated
            network. This simulates a typical CCDC scenario.
          </p>

          <h3>Step 1: Create the Application Network</h3>
          <pre><code># Create a dedicated network for our application stack
docker network create webapp-network</code></pre>

          <h3>Step 2: Deploy MySQL Database</h3>
          <pre><code># Deploy MySQL with a pre-configured database and user
docker run -d --name webapp-db \
  --network webapp-network \
  -v webapp-mysql-data:/var/lib/mysql \
  -e MYSQL_ROOT_PASSWORD=root-secret-2024 \
  -e MYSQL_DATABASE=website \
  -e MYSQL_USER=webuser \
  -e MYSQL_PASSWORD=web-secret \
  mysql:8.0

# Wait for MySQL to initialize
echo "Waiting for MySQL to start..."
sleep 30

# Verify MySQL is running
docker logs webapp-db | tail -10</code></pre>

          <h3>Step 3: Create Sample Database Content</h3>
          <pre><code># Connect to MySQL and create some sample data
docker exec -i webapp-db mysql -u root -proot-secret-2024 website << 'EOF'
CREATE TABLE visitors (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    visit_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ip_address VARCHAR(45)
);

INSERT INTO visitors (name, ip_address) VALUES 
('Alice Johnson', '192.168.1.100'),
('Bob Smith', '192.168.1.101'),
('Charlie Brown', '192.168.1.102');

CREATE TABLE page_views (
    id INT AUTO_INCREMENT PRIMARY KEY,
    page_name VARCHAR(100) NOT NULL,
    view_count INT DEFAULT 0
);

INSERT INTO page_views (page_name, view_count) VALUES 
('Home', 1250),
('About', 347),
('Contact', 89);
EOF

echo "Sample data created successfully"</code></pre>

          <h3>Step 4: Deploy Nginx Web Server</h3>
          <pre><code># Deploy nginx on the same network
docker run -d --name webapp-frontend \
  --network webapp-network \
  -p 8080:80 \
  -v webapp-content:/usr/share/nginx/html \
  nginx

# Create a dynamic webpage that connects to the database
cat > webapp-index.php << 'EOF'
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;CCDC Lab Web Application&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; margin: 40px; background: #f4f4f4; }
        .container { background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        .header { color: #2c3e50; border-bottom: 2px solid #3498db; }
        .status { color: #27ae60; font-weight: bold; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;h1 class="header"&gt;CCDC Training Web Application&lt;/h1&gt;
        &lt;p class="status"&gt;✓ Multi-container application running&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;Frontend:&lt;/strong&gt; Nginx (Container: webapp-frontend)&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;Database:&lt;/strong&gt; MySQL 8.0 (Container: webapp-db)&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;Network:&lt;/strong&gt; webapp-network&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
EOF

# Copy the webpage to the nginx container
docker cp webapp-index.php webapp-frontend:/usr/share/nginx/html/index.html</code></pre>

          <h3>Step 5: Test Inter-Container Communication</h3>
          <pre><code># Test network connectivity between containers
echo "Testing connectivity from frontend to database..."
docker exec webapp-frontend ping -c 3 webapp-db

# Install MySQL client in the nginx container for testing
docker exec webapp-frontend sh -c "apt-get update && apt-get install -y mysql-client"

# Test database connection from the web container
echo "Testing database connection..."
docker exec webapp-frontend mysql -h webapp-db -u webuser -pweb-secret website -e "SELECT 'Connection successful!' as status;"

# Query the sample data
echo "Retrieving visitor data..."
docker exec webapp-frontend mysql -h webapp-db -u webuser -pweb-secret website -e "SELECT * FROM visitors;"

echo "Retrieving page view statistics..."
docker exec webapp-frontend mysql -h webapp-db -u webuser -pweb-secret website -e "SELECT * FROM page_views;"</code></pre>

          <h3>Step 6: Verify the Web Application</h3>
          <pre><code># Check that the web server is accessible
curl http://localhost:8080

# Or open in browser: http://localhost:8080
echo "Web application available at: http://localhost:8080"</code></pre>

          <p><strong>Success Criteria:</strong></p>
          <ul>
            <li>✓ Both containers can communicate by name</li>
            <li>✓ Database queries return sample data</li>
            <li>✓ Web server serves the application page</li>
            <li>✓ All services are on the same network</li>
          </ul>

          <hr />

          <h2>Part 4: Database Operations and Persistence Testing</h2>
          <p>
            This section demonstrates database operations and tests data
            persistence across container restarts.
          </p>

          <h3>Step 1: Perform Database Operations</h3>
          <pre><code># Add new visitor data
docker exec -i webapp-db mysql -u webuser -pweb-secret website << 'EOF'
INSERT INTO visitors (name, ip_address) VALUES ('Lab Student', '192.168.1.200');
UPDATE page_views SET view_count = view_count + 1 WHERE page_name = 'Home';
EOF

# Verify the data was added
echo "Updated visitor list:"
docker exec webapp-frontend mysql -h webapp-db -u webuser -pweb-secret website -e "SELECT * FROM visitors ORDER BY visit_time DESC;"

echo "Updated page view counts:"
docker exec webapp-frontend mysql -h webapp-db -u webuser -pweb-secret website -e "SELECT * FROM page_views;"</code></pre>

          <h3>Step 2: Test Data Persistence</h3>
          <pre><code># Stop and remove the database container
docker stop webapp-db
docker rm webapp-db

# Recreate the database container with the same volume
docker run -d --name webapp-db \
  --network webapp-network \
  -v webapp-mysql-data:/var/lib/mysql \
  -e MYSQL_ROOT_PASSWORD=root-secret-2024 \
  -e MYSQL_DATABASE=website \
  -e MYSQL_USER=webuser \
  -e MYSQL_PASSWORD=web-secret \
  mysql:8.0

# Wait for MySQL to restart
echo "Waiting for MySQL to restart..."
sleep 30

# Verify data persistence
echo "Checking if data persisted after container restart:"
docker exec webapp-frontend mysql -h webapp-db -u webuser -pweb-secret website -e "SELECT COUNT(*) as total_visitors FROM visitors;"
docker exec webapp-frontend mysql -h webapp-db -u webuser -pweb-secret website -e "SELECT * FROM visitors WHERE name = 'Lab Student';"</code></pre>

          <p>
            <strong>Expected Result:</strong> Your data should still be there,
            proving that named volumes preserve database state across container
            restarts.
          </p>

          <hr />

          <h2>Part 5: Backup and Recovery Practice</h2>
          <p>Practice backing up and restoring your application data.</p>

          <h3>Step 1: Create Application Backup</h3>
          <pre><code># Create backup directory
mkdir -p ~/lab-backups
cd ~/lab-backups

# Backup the database
docker exec webapp-db mysqldump -u root -proot-secret-2024 website > website-backup.sql

# Backup the web content
docker cp webapp-frontend:/usr/share/nginx/html/ ./web-content/

# Backup volumes
docker run --rm -v webapp-mysql-data:/source -v $(pwd):/backup alpine tar czf /backup/mysql-volume.tar.gz -C /source .
docker run --rm -v webapp-content:/source -v $(pwd):/backup alpine tar czf /backup/webapp-volume.tar.gz -C /source .

echo "Backup completed. Files:"
ls -la</code></pre>

          <h3>Step 2: Simulate Data Loss and Recovery</h3>
          <pre><code># Simulate malicious data deletion
echo "Simulating Red Team attack - deleting data..."
docker exec -i webapp-db mysql -u root -proot-secret-2024 website << 'EOF'
DROP TABLE visitors;
DROP TABLE page_views;
EOF

# Verify data is gone
docker exec webapp-frontend mysql -h webapp-db -u webuser -pweb-secret website -e "SHOW TABLES;" || echo "Tables deleted by 'Red Team'"

# Restore from backup
echo "Restoring from backup..."
docker exec -i webapp-db mysql -u root -proot-secret-2024 website < website-backup.sql

# Verify restoration
echo "Verifying data restoration:"
docker exec webapp-frontend mysql -h webapp-db -u webuser -pweb-secret website -e "SELECT COUNT(*) as recovered_visitors FROM visitors;"
docker exec webapp-frontend mysql -h webapp-db -u webuser -pweb-secret website -e "SELECT * FROM page_views;"</code></pre>

          <p><strong>Success Criteria:</strong></p>
          <ul>
            <li>✓ Backup created successfully</li>
            <li>✓ Data loss simulated</li>
            <li>✓ Data restored from backup</li>
            <li>✓ Application functionality verified</li>
          </ul>

          <hr />

          <h2>Final Cleanup</h2>
          <p>
            Clean up all containers, networks, and volumes created during this
            lab.
          </p>
          <pre><code># Stop and remove all containers
docker rm -f container-a container-b new-container another-container webapp-frontend webapp-db

# Remove networks
docker network rm my-lab-net webapp-network

# Remove volumes (WARNING: This deletes all data)
echo "Removing volumes - all data will be lost"
docker volume rm lab-data webapp-mysql-data webapp-content

# Clean up backup files
rm -rf ~/lab-backups

echo "Lab cleanup completed"</code></pre>

          <h2>Lab Summary</h2>
          <p><strong>What You Accomplished:</strong></p>
          <ol>
            <li>
              ✅ <strong>Basic Networking</strong>: Containers communicating on
              user-defined networks
            </li>
            <li>
              ✅ <strong>Data Persistence</strong>: Named volumes surviving
              container deletion
            </li>
            <li>
              ✅ <strong>Multi-Service Applications</strong>: Web server +
              database integration
            </li>
            <li>
              ✅ <strong>Database Operations</strong>: Creating, querying, and
              modifying data
            </li>
            <li>
              ✅ <strong>Network Security</strong>: Isolated application
              networks
            </li>
            <li>
              ✅ <strong>Backup & Recovery</strong>: Protecting against data
              loss
            </li>
            <li>
              ✅ <strong>Incident Response</strong>: Recovering from simulated
              attacks
            </li>
          </ol>

          <p><strong>Key CCDC Skills Developed:</strong></p>
          <ul>
            <li>Container networking for secure multi-tier applications</li>
            <li>Database management and backup strategies</li>
            <li>Service recovery and data restoration</li>
            <li>Application stack deployment and maintenance</li>
          </ul>
        </div>
        <div
          class="tab-pane fade"
          id="homework-content"
          role="tabpanel"
          aria-labelledby="homework-tab"
        >
          <h1>
            <i class="bi bi-pencil-square"></i> Week 1: Business Inject - Container Deployment SOP
          </h1>
          
          <div class="alert alert-info" role="alert">
            <h4 class="alert-heading"><i class="bi bi-envelope-fill"></i> CCDC Business Inject</h4>
            <p class="mb-0">The following is a simulated business inject that you might receive during a CCDC competition. Your response should be professional, thorough, and demonstrate security best practices.</p>
          </div>

          <div class="card mb-4">
            <div class="card-header bg-primary text-white">
              <h5 class="mb-0"><i class="bi bi-envelope"></i> Email Communication</h5>
            </div>
            <div class="card-body">
              <p><strong>From:</strong> sarah.chen@techcorp.local (Chief Technology Officer)<br>
              <strong>To:</strong> ccdc-team@techcorp.local<br>
              <strong>Subject:</strong> URGENT: New Container Deployment Standards Required<br>
              <strong>Priority:</strong> High<br>
              <strong>Date:</strong> Competition Day 1, 09:15 AM</p>
              
              <hr>
              
              <p>Team,</p>
              
              <p>Following last month's security incident where an improperly configured container led to a data breach, our board of directors has mandated that we establish formal Standard Operating Procedures (SOPs) for all container deployments.</p>
              
              <p>I need your team to develop a comprehensive <strong>Container Deployment Security SOP</strong> that addresses the following business requirements:</p>
              
              <ul>
                <li><strong>Regulatory Compliance:</strong> Must meet SOC 2 Type II and ISO 27001 requirements</li>
                <li><strong>Risk Management:</strong> Document all security controls and their business justification</li>
                <li><strong>Operational Excellence:</strong> Provide clear, repeatable procedures for our development teams</li>
                <li><strong>Incident Prevention:</strong> Address the root causes from our previous breach</li>
              </ul>
              
              <p>This SOP will be reviewed by our external auditors next week and must be ready for immediate implementation across all production systems.</p>
              
              <p><strong>Deliverable Requirements:</strong></p>
              <ol>
                <li>Complete SOP document following our corporate template</li>
                <li>Technical validation using a sample service deployment</li>
                <li>Executive summary highlighting key security controls</li>
                <li>Implementation timeline and resource requirements</li>
              </ol>
              
              <p>Please have this completed by <strong>end of business today</strong>. Our development team is waiting to deploy a new customer portal, and we cannot proceed without these security standards in place.</p>
              
              <p>The reputation of TechCorp and our clients' trust depends on getting this right.</p>
              
              <p>Best regards,<br>
              Sarah Chen<br>
              Chief Technology Officer<br>
              TechCorp Industries</p>
              
              <p><em>This email contains confidential and proprietary information. Unauthorized distribution is prohibited.</em></p>
            </div>
          </div>

          <div class="alert alert-warning" role="alert">
            <h4 class="alert-heading"><i class="bi bi-clock-history"></i> Competition Context</h4>
            <p><strong>Time Pressure:</strong> You have limited time to respond professionally while maintaining technical accuracy.</p>
            <p><strong>Business Impact:</strong> Your response affects company operations, compliance, and customer trust.</p>
            <p class="mb-0"><strong>Scoring Criteria:</strong> Responses will be evaluated on completeness, technical accuracy, business communication, and adherence to security best practices.</p>
          </div>

          <h2>Your Assignment</h2>
          <p>
            Create a professional response to this business inject by developing the requested Container Deployment Security SOP. Choose a specific service (e.g., WordPress, GitLab, Nginx) and complete the template below with appropriate technical and business justifications.
          </p>
          
          <div class="alert alert-success" role="alert">
            <h4 class="alert-heading"><i class="bi bi-check-circle"></i> Deliverable Template</h4>
            <p class="mb-0">Complete the following SOP template. Replace all placeholder text with service-specific information and provide detailed justifications for each security control.</p>
          </div>
          
          <hr />
          <h2>SOP Template: Secure Container Deployment</h2>
          <table class="table table-bordered">
            <tbody>
              <tr>
                <th style="width: 30%">Procedure Title</th>
                <td><em>[Enter procedure title]</em></td>
              </tr>
              <tr>
                <th>SOP ID</th>
                <td><em>[Enter SOP identifier]</em></td>
              </tr>
              <tr>
                <th>Date</th>
                <td><em>[Enter current date]</em></td>
              </tr>
              <tr>
                <th>Author</th>
                <td><em>[Enter your name/team name]</em></td>
              </tr>
            </tbody>
          </table>
          <hr />
          <h3>1. Service Identification</h3>
          <table class="table table-bordered">
            <thead>
              <tr>
                <th>Item</th>
                <th>Details</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Service Name</strong></td>
                <td><em>[Enter service name]</em></td>
              </tr>
              <tr>
                <td><strong>Business Purpose</strong></td>
                <td><em>[Describe business purpose and value]</em></td>
              </tr>
              <tr>
                <td><strong>Data Sensitivity</strong></td>
                <td><em>[Classify data sensitivity and business impact]</em></td>
              </tr>
            </tbody>
          </table>
          <hr />
          <h3>2. Image Selection & Validation</h3>
          <table class="table table-bordered">
            <thead>
              <tr>
                <th>Rule</th>
                <th>Specification / Command</th>
                <th>Justification</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>1. Use Official Image</strong></td>
                <td><em>[Specify image source and verification method]</em></td>
                <td><em>[Provide business and security justification]</em></td>
              </tr>
              <tr>
                <td><strong>2. Pin to Specific Tag/Digest</strong></td>
                <td><em>[Specify exact image tag and version]</em></td>
                <td><em>[Explain version control and stability benefits]</em></td>
              </tr>
              <tr>
                <td><strong>3. Verify Image Provenance</strong></td>
                <td><em>[Describe verification commands/process]</em></td>
                <td><em>[Explain supply chain security importance]</em></td>
              </tr>
            </tbody>
          </table>
          <hr />
          <h3>3. Runtime Configuration</h3>
          <table class="table table-bordered">
            <thead>
              <tr>
                <th>Rule</th>
                <th>Specification / Command</th>
                <th>Justification</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>1. Run as Non-Root User</strong></td>
                <td><em>[Specify user configuration for your service]</em></td>
                <td><em>[Explain privilege reduction benefits]</em></td>
              </tr>
              <tr>
                <td><strong>2. Create Dedicated Network</strong></td>
                <td><em>[Specify network creation command]</em></td>
                <td><em>[Explain network isolation benefits]</em></td>
              </tr>
              <tr>
                <td><strong>3. Expose Specific Ports</strong></td>
                <td><em>[Specify port mapping configuration]</em></td>
                <td><em>[Explain attack surface reduction]</em></td>
              </tr>
              <tr>
                <td><strong>4. Set Read-Only Filesystem</strong></td>
                <td><em>[Specify read-only configuration]</em></td>
                <td><em>[Explain filesystem protection benefits]</em></td>
              </tr>
            </tbody>
          </table>
          <hr />
          <h3>4. Data Persistence & Volumes</h3>
          <table class="table table-bordered">
            <thead>
              <tr>
                <th>Rule</th>
                <th>Specification / Command</th>
                <th>Justification</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>1. Use Named Volumes</strong></td>
                <td><em>[Specify volume configuration for your service]</em></td>
                <td><em>[Explain data management and portability benefits]</em></td>
              </tr>
              <tr>
                <td><strong>2. Avoid Host Bind Mounts</strong></td>
                <td><em>[Specify what mount types to avoid]</em></td>
                <td><em>[Explain security risks of bind mounts]</em></td>
              </tr>
              <tr>
                <td><strong>3. Document Volume Purpose</strong></td>
                <td><em>[List each volume and its specific purpose]</em></td>
                <td><em>[Explain importance for backup/recovery operations]</em></td>
              </tr>
            </tbody>
          </table>
          <hr />
          <h3>5. Final Deployment Command</h3>
          <p><em>Combine all the rules above into a complete deployment procedure for your chosen service.</em></p>
          <pre><code># [Insert your complete deployment commands here]
# Include network creation, volume setup, and container deployment
# Apply all security controls defined in sections 1-4

# Example structure:
# docker network create [network-name]
# docker volume create [volume-name]
# docker run [all security flags] [image:tag]
</code></pre>
          
          <hr />
          <h3>6. Executive Summary</h3>
          <div class="alert alert-secondary">
            <p><strong>Required:</strong> Provide a 2-3 paragraph executive summary for the CTO highlighting:</p>
            <ul>
              <li>Key security controls implemented</li>
              <li>Compliance alignment (SOC 2, ISO 27001)</li>
              <li>Risk mitigation achieved</li>
              <li>Implementation timeline and resource requirements</li>
            </ul>
          </div>
          
          <p><em>[Write your executive summary here]</em></p>
        </div>
      </div>
      <footer class="py-4 mt-4 text-muted border-top">
        CCDC Training Workshop
      </footer>
    </div>

    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
      crossorigin="anonymous"
    ></script>
  </body>
</html>
