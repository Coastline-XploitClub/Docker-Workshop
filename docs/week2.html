<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Week 2 - Docker Deploy</title>
    <link
      rel="stylesheet"
      href="https://bootswatch.com/5/darkly/bootstrap.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Montserrat", sans-serif;
      }

      pre {
        background-color: #2c3e50;
        color: #eae9e9;
        padding: 1rem;
        border-radius: 0.25rem;
        white-space: pre-wrap;
        word-wrap: break-word;
      }

      .tab-content {
        border: 1px solid #dee2e6;
        border-top: 0;
        padding: 1.5rem;
        border-radius: 0 0 0.375rem 0.375rem;
      }

      .nav-pills .nav-link {
        border-radius: 0.375rem 0.375rem 0 0;
      }

      .code-container {
        position: relative;
      }

      .copy-btn {
        position: absolute;
        top: 8px;
        right: 8px;
        background: rgba(0, 0, 0, 0.7);
        border: none;
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        cursor: pointer;
        opacity: 0;
        transition: opacity 0.2s;
      }

      .code-container:hover .copy-btn {
        opacity: 1;
      }

      .copy-btn:hover {
        background: rgba(0, 0, 0, 0.9);
      }

      .copy-btn.copied {
        background: #28a745;
      }
    </style>
  </head>

  <body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
      <div class="container-fluid">
        <a class="navbar-brand" href="index.html">CCDC Container Workshop</a>
        <button
          class="navbar-toggler"
          type="button"
          data-bs-toggle="collapse"
          data-bs-target="#navbarNav"
          aria-controls="navbarNav"
          aria-expanded="false"
          aria-label="Toggle navigation"
        >
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
          <ul class="navbar-nav">
            <li class="nav-item">
              <a class="nav-link" href="index.html">Home</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="week1.html">Week 1</a>
            </li>
            <li class="nav-item">
              <a class="nav-link active" aria-current="page" href="week2.html"
                >Week 2</a
              >
            </li>
          </ul>
        </div>
      </div>
    </nav>

    <div class="container mt-4">
      <ul class="nav nav-pills nav-fill" id="week2Tab" role="tablist">
        <li class="nav-item" role="presentation">
          <button
            class="nav-link active"
            id="lecture-tab"
            data-bs-toggle="tab"
            data-bs-target="#lecture-content"
            type="button"
            role="tab"
            aria-controls="lecture-content"
            aria-selected="true"
          >
            <i class="bi bi-easel-fill"></i> Lecture & Demo
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="lab-tab"
            data-bs-toggle="tab"
            data-bs-target="#lab-content"
            type="button"
            role="tab"
            aria-controls="lab-content"
            aria-selected="false"
          >
            <i class="bi bi-terminal-fill"></i> Lab
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button
            class="nav-link"
            id="homework-tab"
            data-bs-toggle="tab"
            data-bs-target="#homework-content"
            type="button"
            role="tab"
            aria-controls="homework-content"
            aria-selected="false"
          >
            <i class="bi bi-pencil-square"></i> Homework
          </button>
        </li>
      </ul>
      <div class="tab-content" id="week2TabContent">
        <div
          class="tab-pane fade show active"
          id="lecture-content"
          role="tabpanel"
          aria-labelledby="lecture-tab"
        >
          <h1>
            <i class="bi bi-easel-fill"></i> Week 2: Docker Deploy - Lecture &
            Demo
          </h1>

          <div class="alert alert-warning" role="alert">
            <h4 class="alert-heading">
              <i class="bi bi-exclamation-triangle-fill"></i> Prerequisites
              Check
            </h4>
            <p>
              <strong
                >Before starting this week's exercises, ensure you have the
                following installed:</strong
              >
            </p>
            <div class="row">
              <div class="col-md-6">
                <h5>Required Software:</h5>
                <ul class="mb-0">
                  <li><strong>Docker</strong> (assumed already installed)</li>
                  <li><strong>Node.js 18+</strong> with npm</li>
                  <li><strong>PostgreSQL client tools</strong> (psql)</li>
                  <li>
                    <strong>Make</strong> and <strong>build-essential</strong>
                  </li>
                  <li>
                    <strong>curl</strong>, <strong>tmux</strong>,
                    <strong>tree</strong>, and <strong>jq</strong> for testing
                  </li>
                </ul>
              </div>
              <div class="col-md-6">
                <h5>Quick Install (Ubuntu/Debian):</h5>
                <pre><code># Update package list
sudo apt update && sudo apt dist-upgrade -y

# Install Node.js 18 via NodeSource
curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
sudo apt install -y nodejs

# Install development tools
sudo apt install -y make build-essential

# Install PostgreSQL client and utilities
sudo apt install -y postgresql-client

# Install testing utilities
sudo apt install -y curl jq tmux tree

# Clone the Week 2 repository
git clone -b Week-2 https://github.com/Coastline-XploitClub/Docker-Workshop.git
cd Docker-Workshop/assets/lecture/

# Verify installations
node --version  # Should be 18.x or higher
npm --version
make --version
psql --version</code></pre>
              </div>
            </div>
            <p class="mt-3 mb-0">
              <strong>Alternative:</strong> Use <strong>nvm</strong> (Node
              Version Manager) for easier Node.js management:
              <code>nvm install 18 && nvm use 18</code>
            </p>
          </div>

          <h2>1. Full Stack Application Analysis</h2>
          <p>
            Before containerizing applications, we need to understand how they
            work as host-based services. In CCDC competitions, you'll often
            encounter legacy applications that need analysis before migration or
            hardening. Let's examine a typical full stack application.
          </p>

          <h3>Application Architecture Overview</h3>
          <p>
            Our sample application demonstrates a common three-tier
            architecture:
          </p>
          <ul>
            <li>
              <strong>Frontend:</strong> React client with Vite build system
            </li>
            <li><strong>Backend:</strong> Node.js Express API server</li>
            <li><strong>Database:</strong> PostgreSQL for persistent data</li>
          </ul>

          <h3>Analyzing the Node.js API Backend</h3>
          <p>
            Let's start by understanding the backend service requirements and
            dependencies.
          </p>

          <h4>Service Dependencies Analysis</h4>
          <pre><code># package.json file contents
{
  "name": "api-node",
  "version": "1.0.0",
  "description": "simple api that connects to postgres",
  "main": "src/index.js",
  "scripts": {
    "dev": "nodemon src/index.js",
    "debug": "nodemon --inspect ./src/index.js",
    "debug-docker": "nodemon --inspect=0.0.0.0:9229 ./src/index.js",
    "test": "jest"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "express": "^4.18.2",
    "morgan": "^1.10.0",
    "pg": "^8.8.0"
  },
  "devDependencies": {
    "jest": "^29.4.1",
    "nodemon": "^2.0.20"
  }
}
</code></pre>

          <h4>Health Check Implementation</h4>
          <pre><code># healthcheck/healthcheck.js file contents
var http = require('http');

var options = {
  timeout: 2000,
  host: 'localhost',
  port: process.env.PORT || 3000,
  path: '/ping',
};

var request = http.request(options, (res) => {
  console.info('STATUS: ' + res.statusCode);
  process.exitCode = res.statusCode === 200 ? 0 : 1;
  process.exit();
});

request.on('error', function (err) {
  console.error('ERROR', err);
  process.exit(1);
});

request.end();

</code></pre>

          <h4>Database Connection Module</h4>
          <pre><code># src/db.js file contents
const fs = require('fs');

const { Pool } = require('pg');

databaseUrl =
  process.env.DATABASE_URL ||
  fs.readFileSync(process.env.DATABASE_URL_FILE, 'utf8');

const pool = new Pool({
  connectionString: databaseUrl,
});

// the pool will emit an error on behalf of any idle clients
// it contains if a backend error or network partition happens
pool.on('error', (err, client) => {
  console.error('Unexpected error on idle client', err);
  process.exit(-1);
});

// async/await - check out a client
const getDateTime = async () => {
  const client = await pool.connect();
  try {
    const res = await client.query('SELECT NOW() as now;');
    return res.rows[0];
  } catch (err) {
    console.log(err.stack);
  } finally {
    client.release();
  }
};

module.exports = { getDateTime };
</code></pre>

          <h4>Main Application Server</h4>
          <pre><code># src/index.js file contents
const { getDateTime } = require('./db');

const express = require('express');
const morgan = require('morgan');

const app = express();
const port = process.env.PORT || 3000;

// setup the logger
app.use(morgan('tiny'));

app.get('/', async (req, res) => {
  const dateTime = await getDateTime();
  const response = dateTime;
  response.api = 'node';
  res.send(response);
});

app.get('/ping', async (_, res) => {
  res.send('pong');
});

const server = app.listen(port, () => {
  console.log(`Example app listening on port ${port}`);
});

process.on('SIGTERM', () => {
  console.debug('SIGTERM signal received: closing HTTP server');
  server.close(() => {
    console.debug('HTTP server closed');
  });
});
</code></pre>

          <p><strong>Key Analysis Points:</strong></p>
          <ul>
            <li><strong>Runtime:</strong> Node.js with Express.js framework</li>
            <li><strong>Database:</strong> PostgreSQL connection required</li>
            <li>
              <strong>Port:</strong> Configurable via PORT environment variable
              (default: 3000)
            </li>
            <li>
              <strong>Health Check:</strong> `/ping` endpoint returns "pong"
            </li>
            <li>
              <strong>Endpoints:</strong> Root endpoint `/` returns database
              timestamp with API identifier
            </li>
            <li>
              <strong>Logging:</strong> Morgan middleware for HTTP request
              logging
            </li>
            <li>
              <strong>Graceful Shutdown:</strong> SIGTERM signal handling
              implemented
            </li>
          </ul>

          <p><strong>Configuration Requirements:</strong></p>
          <ul>
            <li>
              <code>DATABASE_URL</code> - Direct database connection string
              (primary option)
            </li>
            <li>
              <code>DATABASE_URL_FILE</code> - Path to file containing
              connection string (fallback option, used for Docker secrets)
            </li>
            <li>
              <code>PORT</code> - Service listening port (optional, default:
              3000)
            </li>
          </ul>

          <h3>Analyzing the React Frontend</h3>
          <p>
            The frontend requires build-time compilation and runtime serving
            infrastructure.
          </p>

          <h4>Build Requirements</h4>
          <pre><code># package.json file contents
{
  "name": "client-react",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite --host",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tanstack/react-query": "^4.22.4",
    "axios": "^1.2.3",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@tanstack/react-query-devtools": "^4.24.4",
    "@types/react": "^18.0.26",
    "@types/react-dom": "^18.0.9",
    "@vitejs/plugin-react-swc": "^3.0.0",
    "vite": "^4.0.0"
  }
}
</code></pre>

          <h4>Nginx Reverse Proxy Configuration</h4>
          <pre><code># nginx.conf - Production serving strategy
server {
  listen 8080;
  
  # Docker internal dns server
  resolver 127.0.0.11;
  
  location /ping {
        access_log off;
        add_header 'Content-Type' 'text/plain';
        return 200 "pong";
  }
  location /api/node/ {
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Server $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_http_version 1.1;

        set $api_node_upstream http://api-node:3000/;
        proxy_pass $api_node_upstream;
  }
  location / {
    root /usr/share/nginx/html;
    index index.html index.htm;
    try_files $uri $uri/ /index.html =404;
  }
  
  include /etc/nginx/extra-conf.d/*.conf;
}</code></pre>

          <h4>React Frontend Application</h4>
          <pre><code># src/App.jsx file contents
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from "@tanstack/react-query";
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import axios from "axios";

import './App.css'

const queryClient = new QueryClient();

function CurrentTime(props) {
  const { isLoading, error, data, isFetching } = useQuery({
    queryKey: [props.api],
    queryFn: () =&gt;
      axios
        .get(`${props.api}`)
        .then((res) =&gt; res.data),
  });

  if (isLoading) return `Loading ${props.api}... `;

  if (error) return "An error has occurred: " + error.message;

  return (
    &lt;div className="App"&gt;
      &lt;p&gt;---&lt;/p&gt;
      &lt;p&gt;API: {data.api}&lt;/p&gt;
      &lt;p&gt;Time from DB: {data.now}&lt;/p&gt;
      &lt;div&gt;{isFetching ? "Updating..." : ""}&lt;/div&gt;
    &lt;/div&gt;
  )
}

export function App() {
  return (
    &lt;QueryClientProvider client={queryClient}&gt;
      &lt;h1&gt;Hey Team! üëã&lt;/h1&gt;
      &lt;CurrentTime api="/api/node/"/&gt;
      &lt;ReactQueryDevtools initialIsOpen={false} /&gt;
    &lt;/QueryClientProvider&gt;
  );
}

export default App
</code></pre>

          <p><strong>Key Analysis Points:</strong></p>
          <ul>
            <li><strong>Framework:</strong> React 18 with Vite build tool</li>
            <li>
              <strong>State Management:</strong> TanStack React Query for server
              state
            </li>
            <li><strong>API Communication:</strong> Axios for HTTP requests</li>
            <li>
              <strong>Development Tools:</strong> React Query DevTools for
              debugging
            </li>
            <li>
              <strong>Build Process:</strong> Vite for fast development and
              production builds
            </li>
            <li>
              <strong>Proxy Configuration:</strong> API calls routed through
              Nginx reverse proxy
            </li>
            <li>
              <strong>Error Handling:</strong> Built-in error states for API
              failures
            </li>
            <li>
              <strong>Loading States:</strong> UI feedback during data fetching
            </li>
          </ul>

          <p><strong>Configuration Requirements:</strong></p>
          <ul>
            <li>
              <strong>Build Output:</strong> Static files generated to
              <code>dist/</code> directory
            </li>
            <li>
              <strong>API Endpoint:</strong> Frontend expects API at
              <code>/api/node/</code> path
            </li>
            <li>
              <strong>Nginx Serving:</strong> Requires reverse proxy for API and
              static file serving
            </li>
            <li>
              <strong>Node.js Version:</strong> Compatible with Vite build
              requirements
            </li>
            <li>
              <strong>Environment:</strong> Production build needed for
              deployment
            </li>
          </ul>

          <p><strong>CCDC Analysis Checklist:</strong></p>
          <ol>
            <li>
              ‚úÖ <strong>Dependencies identified</strong> - Node.js, PostgreSQL,
              Nginx
            </li>
            <li>
              ‚úÖ <strong>Ports mapped</strong> - API: 3000, Frontend: 8080, DB:
              5432
            </li>
            <li>
              ‚úÖ <strong>Environment variables documented</strong> -
              DATABASE_URL, PORT
            </li>
            <li>
              ‚úÖ <strong>Health checks available</strong> - /ping endpoints for
              monitoring
            </li>
            <li>
              ‚úÖ <strong>Service communication</strong> - Frontend ‚Üí API via
              proxy
            </li>
          </ol>

          <hr />

          <h2>2. Running the Application Locally</h2>
          <p>
            Before containerizing any application, it's crucial to understand
            how it works as a traditional host-based service. This helps
            identify dependencies, configuration requirements, and potential
            issues during migration. Let's run our full stack application
            locally to interact with it.
          </p>

          <div class="alert alert-success" role="alert">
            <h4 class="alert-heading">
              <i class="bi bi-play-circle-fill"></i> Hands-On Exercise: Local
              Application Deployment
            </h4>
            <p>
              Follow these steps to run the complete application stack on your
              local machine. Since you're connected via SSH and will need
              multiple terminal sessions, we'll use tmux to manage everything
              efficiently.
            </p>
          </div>

          <h3>Step 0: Set Up tmux Session Management</h3>
          <p>
            Since this exercise requires multiple terminal sessions (database,
            API server, frontend server, and testing), we'll use tmux to manage
            them all within your SSH connection. This prevents losing work if
            your SSH connection drops and makes it easy to switch between
            different components.
          </p>

          <h4>Create and Configure tmux Session</h4>
          <pre><code># Start a new tmux session named 'ccdc-app'
tmux new-session -d -s ccdc-app

# Attach to the session
tmux attach-session -t ccdc-app

# You're now in tmux! The status bar at the bottom shows:
# [0] 0:bash*    "hostname"  DD-MMM HH:MM</code></pre>

          <h4>Create Named Windows for Each Component</h4>
          <pre><code># Create and name windows for each service
# Window 0: Main/Setup (current window)
Ctrl+b ,
# Type: setup
# Press Enter

# Create new window for database
Ctrl+b c
Ctrl+b ,
# Type: database
# Press Enter

# Create new window for API server  
Ctrl+b c
Ctrl+b ,
# Type: api
# Press Enter

# Create new window for frontend
Ctrl+b c
Ctrl+b ,
# Type: frontend
# Press Enter

# Create new window for testing
Ctrl+b c
Ctrl+b ,
# Type: testing
# Press Enter</code></pre>

          <h4>tmux Navigation Reference</h4>
          <pre><code># Essential tmux commands (Ctrl+b is the prefix key):
Ctrl+b 0    # Switch to window 0 (setup)
Ctrl+b 1    # Switch to window 1 (database)  
Ctrl+b 2    # Switch to window 2 (api)
Ctrl+b 3    # Switch to window 3 (frontend)
Ctrl+b 4    # Switch to window 4 (testing)

Ctrl+b n    # Next window
Ctrl+b p    # Previous window
Ctrl+b l    # Last used window

Ctrl+b d    # Detach from session (keeps running)
# To reattach later: tmux attach-session -t ccdc-app

Ctrl+b [    # Enter scroll mode (use arrow keys, q to exit)</code></pre>

          <div class="alert alert-info" role="alert">
            <strong>Note:</strong> Your tmux status bar should now show named
            windows: <code>[setup] [database] [api] [frontend] [testing]</code>.
            The asterisk (*) indicates your current window.
          </div>

          <h3>Step 1: Navigate to Application Directory (Setup Window)</h3>
          <p>
            Make sure you're in the "setup" window (Ctrl+b 0) for initial setup:
          </p>
          <pre><code># Navigate to the Docker Workshop lecture assets
cd Docker-Workshop/assets/lecture/

# Verify the application structure
ls -la
# You should see: api-node/ client-react/ Makefile</code></pre>

          <h3>Step 2: Install Application Dependencies</h3>
          <p>
            Both the Node.js API and React frontend need their dependencies
            installed before they can run.
          </p>

          <pre><code># Install API dependencies
cd api-node
npm install
cd ..

# Install React frontend dependencies  
cd client-react
npm install
cd ..

# Verify installations
echo "API dependencies installed:"
ls api-node/node_modules | wc -l

echo "React dependencies installed:"
ls client-react/node_modules | wc -l</code></pre>

          <h3>Step 3: Start PostgreSQL Database (Database Window)</h3>
          <p>
            Switch to the database window (Ctrl+b 1) and start PostgreSQL. We'll
            use Docker to run PostgreSQL while keeping the application code
            running natively.
          </p>

          <pre><code># Switch to database window
Ctrl+b 1

# Navigate to application directory
cd Docker-Workshop/assets/lecture/

# Start PostgreSQL using the provided Makefile
make run-postgres

# Alternative manual command:
# docker run \
#   -e POSTGRES_PASSWORD=ccdc-password \
#   -v pgdata:/var/lib/postgresql/data \
#   -p 5432:5432 \
#   postgres:15.1-alpine

# Verify PostgreSQL is running
docker ps | grep postgres

# Test database connectivity
sleep 5
psql postgres://postgres:ccdc-password@localhost:5432/postgres -c "SELECT version();"</code></pre>

          <h3>Step 4: Start the Node.js API Server (API Window)</h3>
          <p>
            Switch to the API window (Ctrl+b 2) and start the API server. This
            will run in development mode with auto-reload capabilities.
          </p>

          <pre><code># Switch to API window
Ctrl+b 2

# Navigate to application directory
cd Docker-Workshop/assets/lecture/

# Start the API server
make run-api-node

# Alternative manual command:
# cd api-node
# DATABASE_URL=postgres://postgres:ccdc-password@localhost:5432/postgres npm run dev

# You should see output like:
# [nodemon] starting `node src/index.js`
# Example app listening on port 3000</code></pre>

          <h3>Step 5: Test the API Endpoints (Testing Window)</h3>
          <p>
            Switch to the testing window (Ctrl+b 4) to test the API endpoints
            while keeping the API server running in its own window.
          </p>

          <pre><code># Switch to testing window
Ctrl+b 4

# Test API health check
curl http://localhost:3000/ping

# Expected response: pong

# Test the main API endpoint (returns database timestamp)
curl http://localhost:3000/ | jq .

# Expected response:
# {
#   "now": "2024-01-15T10:30:45.123Z",
#   "api": "node"
# }</code></pre>

          <h3>Step 6: Start the React Frontend (Frontend Window)</h3>
          <p>
            Switch to the frontend window (Ctrl+b 3) and start the React
            development server. This will build and serve the frontend with
            hot-reload capabilities.
          </p>

          <pre><code># Switch to frontend window
Ctrl+b 3

# Navigate to application directory
cd Docker-Workshop/assets/lecture/

# Start the React development server
make run-client-react

# Alternative manual command:
# cd client-react
# npm run dev

# You should see output like:
# ‚ûú  Local:   http://localhost:5173/
# ‚ûú  Network: http://192.168.1.100:5173/</code></pre>

          <div class="alert alert-info" role="alert">
            <h5 class="alert-heading">üîç Development vs Production Ports</h5>
            <p><strong>Why different ports?</strong></p>
            <ul class="mb-2">
              <li>
                <strong>Port 5173:</strong> Vite development server (what we're
                running now)
                <ul>
                  <li>Hot module replacement for instant code changes</li>
                  <li>Built-in proxy to API backend</li>
                  <li>Development features and debugging tools</li>
                </ul>
              </li>
              <li>
                <strong>Port 8080:</strong> Production nginx server (for
                containerized deployment)
                <ul>
                  <li>Serves pre-built static files (HTML, CSS, JS)</li>
                  <li>Optimized for performance and security</li>
                  <li>Reverse proxy configuration for API routing</li>
                </ul>
              </li>
            </ul>
            <p class="mb-0">
              <strong>Key point:</strong> We're using development mode now to
              understand the application. Later, when we containerize, we'll use
              the production nginx approach on port 8080.
            </p>
          </div>

          <h3>Step 7: Interact with the Complete Application</h3>
          <p>
            Now you can interact with the full stack application to understand
            its behavior.
          </p>

          <h4>Frontend Access</h4>
          <pre><code># Access the React frontend
open http://localhost:5173
# Or: curl http://localhost:5173</code></pre>

          <h4>Test Frontend-to-API Communication (Testing Window)</h4>
          <pre><code># Switch back to testing window
Ctrl+b 4

# The React app should automatically fetch data from the API
# You can monitor the API logs by switching to the API window (Ctrl+b 2)

# Test the proxy configuration manually
curl http://localhost:5173/api/node/ | jq .

# This should return the same response as the direct API call</code></pre>

          <h4>Monitor Application Behavior Across Windows</h4>
          <pre><code># Use tmux to monitor all components:
Ctrl+b 2    # Check API server logs
Ctrl+b 3    # Check React dev server logs  
Ctrl+b 4    # Return to testing window

# From testing window, refresh the frontend and observe:
# 1. Switch to API window (Ctrl+b 2) - see GET requests
# 2. Database queries are executed (visible in API logs)
# 3. Responses are returned to the frontend
# 4. Switch to frontend window (Ctrl+b 3) - see build/reload activity</code></pre>

          <div class="alert alert-info" role="alert">
            <strong>üí° tmux Session Management:</strong> If your SSH connection
            drops, you can reconnect and reattach to your session with:
            <br /><code>tmux attach-session -t ccdc-app</code> <br />All your
            services will still be running in their respective windows!
          </div>

          <h3>Application Behavior Analysis</h3>
          <p>
            Now that the application is running, let's document what we've
            learned:
          </p>

          <h4>Service Dependencies Confirmed</h4>
          <ul>
            <li>
              ‚úÖ <strong>PostgreSQL Database:</strong> Required for API
              functionality
            </li>
            <li>
              ‚úÖ <strong>Node.js API:</strong> Serves backend logic on port 3000
            </li>
            <li>
              ‚úÖ <strong>React Frontend:</strong> Development server on port
              5173
            </li>
            <li>
              ‚úÖ <strong>Proxy Configuration:</strong> Frontend proxies
              /api/node/ to backend
            </li>
          </ul>

          <h4>Runtime Requirements Identified</h4>
          <ul>
            <li>
              <strong>Database Connection String:</strong>
              postgres://postgres:ccdc-password@localhost:5432/postgres
            </li>
            <li>
              <strong>API Port Configuration:</strong> PORT=3000 (configurable
              via environment)
            </li>
            <li>
              <strong>Frontend Build Process:</strong> Vite handles bundling and
              serving
            </li>
            <li>
              <strong>Inter-Service Communication:</strong> HTTP requests
              between frontend and API
            </li>
          </ul>

          <h4>Production Deployment Considerations</h4>
          <ul>
            <li>
              <strong>Static Asset Serving:</strong> React needs nginx or
              similar for production
            </li>
            <li>
              <strong>Process Management:</strong> Services need proper
              lifecycle management
            </li>
            <li>
              <strong>Environment Configuration:</strong> Database URLs, ports,
              secrets management
            </li>
            <li>
              <strong>Health Monitoring:</strong> Both services provide /ping
              endpoints
            </li>
          </ul>

          <h3>Step 8: Verify Database Activity (Testing Window)</h3>
          <p>
            Let's confirm that the PostgreSQL database is actively being used by
            querying it directly. Every time you access the API (either directly
            or through the React frontend), the application executes
            <code>SELECT NOW() as now;</code> to get the current timestamp.
          </p>

          <pre><code># Switch to testing window
Ctrl+b 4

# Connect directly to the PostgreSQL database
psql postgres://postgres:ccdc-password@localhost:5432/postgres

# Once connected to psql, you can run these queries:

# Check current database time (same as what the API calls)
SELECT NOW() as current_time;

# View active database connections
SELECT pid, usename, application_name, client_addr, state, query_start 
FROM pg_stat_activity 
WHERE state = 'active' OR state = 'idle in transaction';

# Check if pg_stat_statements extension is available
SELECT * FROM pg_available_extensions WHERE name = 'pg_stat_statements';

# If not available, check current database activity instead
SELECT datname, numbackends, xact_commit, xact_rollback 
FROM pg_stat_database 
WHERE datname = 'postgres';

# View current connections and their state
SELECT count(*) as connection_count, state 
FROM pg_stat_activity 
GROUP BY state;

# Exit psql
\q</code></pre>

          <div class="alert alert-success" role="alert">
            <h5 class="alert-heading">‚úÖ Database Integration Confirmed</h5>
            <p><strong>What the API does:</strong></p>
            <ul class="mb-2">
              <li>
                Every request to <code>http://localhost:3000/</code> triggers
                <code>SELECT NOW()</code>
              </li>
              <li>
                Every React frontend load executes this query automatically
              </li>
              <li>
                The database timestamp is returned to show real-time
                connectivity
              </li>
              <li>
                Each query increments the <code>xact_commit</code> counter in
                <code>pg_stat_database</code>
              </li>
            </ul>
            <p class="mb-0">
              <strong>Test it:</strong> Compare the transaction count before and
              after making API calls to see the database activity!
            </p>
          </div>

          <h3>Cleanup and Next Steps</h3>
          <pre><code># When you're done testing, stop the services:
# Ctrl+C in both terminal windows to stop the Node.js and React servers

# Stop and remove the PostgreSQL container
docker stop $(docker ps -q -a)
docker rm $(docker ps -aq -a)

# Remove the database volume
docker volume rm pgdata</code></pre>

          <div class="alert alert-info" role="alert">
            <h4 class="alert-heading">
              <i class="bi bi-lightbulb-fill"></i> CCDC Migration Insight
            </h4>
            <p>
              <strong>What we learned:</strong> By running the application
              locally first, we've identified all the runtime dependencies,
              configuration requirements, and service interactions. This
              information is crucial for creating effective Dockerfiles and
              deployment strategies.
            </p>
            <p class="mb-0">
              <strong>Next step:</strong> Now that we understand how the
              application works, we can containerize each component while
              preserving the same functionality and configuration patterns.
            </p>
          </div>

          <hr />

         
        </div>
        <div
          class="tab-pane fade"
          id="lab-content"
          role="tabpanel"
          aria-labelledby="lab-tab"
        >
          <h1>
            <i class="bi bi-terminal-fill"></i> Week 2: Docker Deploy - Guided
            Lab
          </h1>
          <p>
            <em>Lab content will be added here...</em>
          </p>
        </div>
        <div
          class="tab-pane fade"
          id="homework-content"
          role="tabpanel"
          aria-labelledby="homework-tab"
        >
          <h1>
            <i class="bi bi-pencil-square"></i> Week 2: Business Inject -
            Migration Plan
          </h1>
          <p>
            <em>Homework content will be added here...</em>
          </p>
        </div>
      </div>
      <footer class="py-4 mt-4 text-muted border-top">
        <div class="text-center">
          <p class="mb-0">CCDC Container Workshop</p>
          Designed for Coastline College's CCDC Team by Mike Crawford
          <code>@devurandom11</code>
        </div>
      </footer>
    </div>

    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
      crossorigin="anonymous"
    ></script>
    <script>
      // Add copy buttons to all code blocks
      document.addEventListener("DOMContentLoaded", function () {
        const codeBlocks = document.querySelectorAll(
          "pre code, pre:not(:has(code))"
        );

        codeBlocks.forEach(function (codeBlock) {
          const pre =
            codeBlock.tagName === "PRE" ? codeBlock : codeBlock.parentElement;

          // Wrap pre in container if not already wrapped
          if (!pre.parentElement.classList.contains("code-container")) {
            const container = document.createElement("div");
            container.className = "code-container";
            pre.parentElement.insertBefore(container, pre);
            container.appendChild(pre);
          }

          // Create copy button
          const copyBtn = document.createElement("button");
          copyBtn.className = "copy-btn";
          copyBtn.innerHTML = '<i class="bi bi-clipboard"></i>';
          copyBtn.title = "Copy to clipboard";

          // Add click handler
          copyBtn.addEventListener("click", function () {
            const textToCopy =
              codeBlock.tagName === "CODE"
                ? codeBlock.textContent
                : codeBlock.textContent;

            navigator.clipboard
              .writeText(textToCopy)
              .then(function () {
                copyBtn.innerHTML = '<i class="bi bi-check"></i>';
                copyBtn.classList.add("copied");
                copyBtn.title = "Copied!";

                setTimeout(function () {
                  copyBtn.innerHTML = '<i class="bi bi-clipboard"></i>';
                  copyBtn.classList.remove("copied");
                  copyBtn.title = "Copy to clipboard";
                }, 2000);
              })
              .catch(function (err) {
                console.error("Could not copy text: ", err);
                // Fallback for older browsers
                const textArea = document.createElement("textarea");
                textArea.value = textToCopy;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand("copy");
                document.body.removeChild(textArea);

                copyBtn.innerHTML = '<i class="bi bi-check"></i>';
                copyBtn.classList.add("copied");
                copyBtn.title = "Copied!";

                setTimeout(function () {
                  copyBtn.innerHTML = '<i class="bi bi-clipboard"></i>';
                  copyBtn.classList.remove("copied");
                  copyBtn.title = "Copy to clipboard";
                }, 2000);
              });
          });

          // Add button to container
          pre.parentElement.appendChild(copyBtn);
        });
      });
    </script>
  </body>
</html>
